# Filler script

The form filler script is a YAML file (an example was generated by the [map CLI](../README.md#example-script)).

## Types of inputs

* [Fixed-field inputs](#fixed-field-inputs) are used when there is a 1:1 correlation between the field ID and the config value.
* [Calculated inputs](#calculated-inputs) are used when the either field ID or value to fill depends on the config value.

## Fixed-field inputs

When there is direct correlation between the config value and an input field, then the fixed-field input is the optimal choice.  Fixed-field inputs have the syntax:

```yaml
unique.friendly.key:
  integer: value
```

The key is a unique friendly key, `unique.friendly.key`, is (almost) completely arbitrary (see [Script friendly keys](#script-friendly-keys)).  It is used to help the script maintainer to correlate the value back to the form without having to look at the form.

The `integer` is the unique integer ID assigned to the field.  It can be seen in the example filled PDF that was generated when it built the [map](../README.md#example-script).  It is also in the map file that was generated.  In this way, it is a fixed-field input because the field ID is known in advance.

The `value` is described in [Script values](#script-values).

## Calculated inputs

When either the field ID or the value to fill depends on the config value, then it is necessary to use a field calculated.  Calculated inputs have the syntax:

```yaml
unique.friendly.key:
  value: value
  calculate: |
    (ctx, val) => { field, fill }
```

Sometimes the exact field ID to fill or the ultimate value to input may not be known in advance.  An example of this might be one of *several* check-boxes or radio buttons (these can be very difficult to figure out by the way, see [troubleshooting](#troubleshooting)).  For example, consider a form with radio buttons:

```
Favorite fruit:
  ( ) Apple
  ( ) Banana
```

The config might be:

```yaml
fruit: banana
```

However, the "Apple" and "Banana" radio buttons have *different* input ID.  Depending on the config, there are one of two different inputs to fill.  The solution is to calculate both the ID and the input value to fill, based on the config value.  For example:

```yaml
favorite.fruit:
  value: ${ctx.fruit}
  calculate: |
    (ctx, val) => {
      if (val === 'banana') {
          return { field: 1, fill: '0' };
      } else {
          return { field: 2, fill: '1' };
      }
    }
```

The calculation scripts are by-far the most difficult aspect of form filling.  You need to know your way around JavaScript, and it can be tricky figure out exactly what value will enable/disable a particular check-box or radio (if anyone has insight into this, please let me know).

## Script values

The `value` is computed as a [JavaScript template literal](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).  It can be constant value, e.g. `"Joe Bloggs"` or `1234.00`.  However, JavaScript can the [Javascript Core Objects](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects) also be used within the script.  In addition, there is a pre-defined context, `ctx`, that allows the script to access the configuration file.

```yaml
fill.string:
  0: Joe Bloggs
fill.number:
  0: 1234.00
fill.first.last:
  0: ${ctx.firstName} ${ctx.lastName}
fill.js:
  # fill an ISO 8601 string "2020-04-13T12:31:23.799Z"
  0: ${new Date().toISOString()}
```

In addition, there are a number of built-in [helper functions](#script-helper-functions) that can help clean and sanitize data.

## Script friendly keys

We said that the friendly keys are *mostly* arbitrary.  There are a number of built-in [helper functions](#script-helper-functions) that can help clean and sanitize data.  However, they are not *too* convenient if used a lot.  For example, imagine filling out a form that required large amounts of monetary input, but that the input be rounded to a whole number (no decimal places).  It would be inconvenient to repeatedly write this every time a whole number was required:

```yaml
total.income:
  0: ${currencyWhole(ctx.totalIncome)}
```

It is more convenient to add a suffix and automatically apply a function, e.g.:

```yaml
total.income.whole:
  0: ${ctx.totalIncome}
```


The shorthand suffixes make repetitive inputs more convenient.  However, using them has an added drawback when referring to [Previously filled fields](#previously-filled-fields).  The [API](API.md) has a way to add additional helper functions and shorthand keys.

### Suffix *.currency

If the friendly key ends with `.currency`, then the value will be automatically converted with the [currency](#currency) helper function.

```yaml
fill.number.currency:
  # fills "1,234.00"
  0: 1234
```

### Suffix *.whole

If the friendly key ends with `.whole`, then the value will be automatically converted with the [currencyWhole](#currencyWhole) helper function.

```yaml
fill.number.whole:
  # fills "1,234"
  0: 1234.00
```

### Suffix *.dec

If the friendly key ends with `.dec`, then the value will be automatically converted with the [currencyDec](#currencyDec) helper function.

```yaml
fill.number.dec:
  # fills "00"
  0: 1234.00
```

### Suffix *.nodash

If the friendly key ends with `.nodash`, then the value will automatically be stripped of any `-` dash characters.

```yaml
fill.number.dec:
  # fills "1234"
  0: 12-34
```

## Script helper functions

### currency(number)

Converts the value to a currency value with thousand separators and decimal fraction (without any specific currency designator) using the locale of the operating system.  Unexpected string values will return `"NaN"` and  `undefined` and `null` values will return `0`.

### currencyWhole(number)

Converts the value to a whole currency value with thousands separators, but no decimal fraction (without any specific currency designator) using the local of the operating system.  Unexpected string values will return `"NaN"` and  `undefined` and `null` values will return `0`.

### currencyDec(number)

Returns the decimal fraction of a currency (without the leading decimal separator) using the local of the operating system.  Unexpected string values will return `"NaN"` and  `undefined` and `null` values will return `00`.

### parseCurrency(string)

Parses a currency (ignoring thousand separators) and returns a number with decimal fraction (if present).  E.g. `"1,234.56"` will return `"1234.56"`.

### strCapitalize(string)

Capitalizes the first letter of a string.

### strNoDash(string)

Removes all dashes from a string, e.g. SSN or phone numbers.

### strTrim(string)

Removes all leading and trailing whitespace around a string.

## Previous filled fields

It is possible to access previous filled fields through the `ctx` by accessing the `ctx.forms` by name.

```yaml
adjusted.income.currency:
  0: ${ctx.forms['business'].totalIncome - ctx.forms['business'].expenses}
```
